---
layout: "@layouts/ArticleLayout.astro"
author: Kevin Kelche
title: Concurrency in Go and Goroutines
description: Example description
date: 25 January 2023
image: /images/golang-concurrency.svg
imageDescription:
keywords:
  -
tags:
  - golang

draft: true
---

import SectionLink from "@components/SectionLink.jsx";
import Nugget from "@components/Nugget.astro";
import Link from "@components/Link.jsx";

## Introduction

### Concurrency

Concurrency is the ability of a program to run multiple tasks at the same time. Concurrency is important for programs that need to do multiple things at once, such as a web server that needs to handle multiple requests at the same time. Concurrency is different from parallelism, which is the ability of a program to run multiple tasks at the same time on multiple processors. Go is a concurrent language, but not a parallel language. Go programs can run on multiple processors, but they don't necessarily run in parallel.

### Goroutines

Goroutines enable concurrency in Go. Goroutines can be defined as a lightweight thread of execution. Goroutines are multiplexed onto multiple OS threads. Goroutines are created and managed by the Go runtime.

### Goroutine Scheduling

Goroutines are scheduled by the Go runtime. The Go runtime uses a cooperative scheduling model. This means that goroutines are scheduled by the runtime only when they yield the processor. Goroutines yield the processor when they block on a channel operation, when they call a blocking system call, or when they call the runtime.Gosched() function. The Gosched() function yields the processor to allow other goroutines to run. The Gosched() function is rarely used in practice.

### How Goroutines Work

When a Go program starts, it creates a single goroutine, called the main goroutine. The main goroutine is responsible for calling the main function. All other goroutines are created by the main goroutine. When the main function returns, the program exits, even if other goroutines are still running.

Goroutines are scheduled by the Go runtime. The Go runtime uses a scheduler to schedule goroutines onto OS threads. The Go runtime uses a cooperative scheduling model, which means that goroutines voluntarily give up their time on the OS thread. The Go runtime uses a M:N scheduling model, which means that M goroutines are scheduled onto N OS threads.

Another important thing to note is that goroutines are not preemptively scheduled. This means that goroutines are not scheduled based on priority. Goroutines are scheduled based on availability. This is important because it means that goroutines can be starved if they are not scheduled often enough.
